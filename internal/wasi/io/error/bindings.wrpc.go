// Generated by `wit-bindgen-wrpc-go` 0.9.1. DO NOT EDIT!
package error

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

// A resource which represents some error information.
//
// The only method provided by this resource is `to-debug-string`,
// which provides some human-readable information about the error.
//
// In the `wasi:io` package, this resource is returned through the
// `wasi:io/streams/stream-error` type.
//
// To provide more specific error information, other interfaces may
// provide functions to further "downcast" this error into more specific
// error information. For example, `error`s returned in streams derived
// from filesystem types to be described using the filesystem's own
// error-code type, using the function
// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
// `borrow<error>` and returns
// `option<wasi:filesystem/types/error-code>`.
//
// The set of functions which can "downcast" an `error` into a more
// concrete type is open.
type Error interface{}

// Returns a string that is suitable to assist humans in debugging
// this error.
//
// WARNING: The returned string should not be consumed mechanically!
// It may change across platforms, hosts, or other implementation
// details. Parsing this string is a major platform-compatibility
// hazard.
func Error_ToDebugString(ctx__ context.Context, wrpc__ wrpc.Invoker, self wrpc.Borrow[Error]) (r0__ string, err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(string(self), &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `self` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `self` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "wasi:io/error@0.2.0", "error.to-debug-string", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `[method]error.to-debug-string`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "wasi:io/error@0.2.0", "name", "[method]error.to-debug-string", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "wasi:io/error@0.2.0", "name", "[method]error.to-debug-string", "err", cErr__)
	}
	r0__, err__ = func(r interface {
		io.ByteReader
		io.Reader
	}) (string, error) {
		var x uint32
		var s uint8
		for i := 0; i < 5; i++ {
			slog.Debug("reading string length byte", "i", i)
			b, err := r.ReadByte()
			if err != nil {
				if i > 0 && err == io.EOF {
					err = io.ErrUnexpectedEOF
				}
				return "", fmt.Errorf("failed to read string length byte: %w", err)
			}
			if s == 28 && b > 0x0f {
				return "", errors.New("string length overflows a 32-bit integer")
			}
			if b < 0x80 {
				x = x | uint32(b)<<s
				buf := make([]byte, x)
				slog.Debug("reading string bytes", "len", x)
				_, err = r.Read(buf)
				if err != nil {
					return "", fmt.Errorf("failed to read string bytes: %w", err)
				}
				if !utf8.Valid(buf) {
					return string(buf), errors.New("string is not valid UTF-8")
				}
				return string(buf), nil
			}
			x |= uint32(b&0x7f) << s
			s += 7
		}
		return "", errors.New("string length overflows a 32-bit integer")
	}(r__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
